
---

#### 📝 [50/529] 零停机迁移与读写分离

**1. 🕵️‍♂️ 题眼与约束分析**
* **源端：** 本地 Node.js Apps (Collector, Aggregator) + MySQL。
* **痛点：** 聚合任务（读）运行时，加载任务（写）失败 $\rightarrow$ **锁竞争/性能问题**。
* **目标：** 解决数据加载问题（读写分离）+ 迁移到 AWS + **No interruption** (零停机/不改客户端)。
* **应用类型：** 简单的 Node.js 应用。

**2. ⚡ 秒杀思路**
* **架构优化：** 显然需要将 Aggregator（读）移到 **Read Replica** 上，Collector（写）连主库。
* **迁移工具：** **AWS DMS (Database Migration Service)** 是零停机数据库迁移的神器。
* **应用迁移：**
    * "Simple Node.js apps" $\rightarrow$ 迁移到 EC2 或容器最简单（Lift & Shift）。
    * 选项 A/C 提到了 Lambda。把一个现有的长连接或服务型 Node.js 应用重构为 Lambda 需要改代码（Refactor），风险高，不符合 "Simple migration"。
    * 选项 D (Kinesis): 重构太大。
    * **选项 B:**
        * DB: 本地 $\rightarrow$ DMS $\rightarrow$ Aurora。
        * 读写分离: Aggregator 连 Aurora Read Replica。
        * App: Collector 连 ALB + EC2 ASG (Lift & Shift)。
        * 切换: DNS 切换。
    * 这个方案最稳，改动最小，且通过 Read Replica 解决了原本的锁问题。
    * **锁定 B。**

**3. ✅ 正确选项解析 (选项 B)**
* **DMS:** 持续复制，最小化停机。
* **Read Replica:** 解决 OLTP 和 OLAP 混合负载导致的锁竞争。
* **EC2 ASG:** 平滑迁移现有应用。

**5. 📚 核心考点:** 数据库迁移 (DMS) 与读写分离架构。
