好的，让我们继续进行 AWS SAP 考题解析。

---

📝 **1/529. 混合 DNS 架构 (On-Premises + AWS Route 53 Resolver)**

1.  **🕵️‍♂️ 题眼与约束分析**
    * **核心需求**：构建混合 DNS 解决方案。
    * **解析目标**：
        1.  本地系统（On-Prem）$\rightarrow$ 解析 AWS VPC 内的私有域名 `cloud.example.com`（Route 53 私有托管区域）。
        2.  所有 VPC $\rightarrow$ 解析 `cloud.example.com`。
    * **连接**：已有 Direct Connect 连接本地和 Transit Gateway (TGW)。
    * **目标**：**最高性能 (Highest Performance)**。

2.  **⚡ 秒杀思路**
    * **本地解析 AWS 私有域名**：必须使用 **Route 53 Inbound Resolver (入站解析器)**。本地 DNS 服务器配置转发规则指向 Inbound Resolver 的 IP。
    * **最高性能/最佳实践**：通常在 **共享服务 VPC (Shared Services VPC)** 中集中部署 Resolver 端点，并通过 TGW 让所有 VPC 和本地网络访问。
    * **VPC 内解析**：只要 VPC 关联了私有托管区域 (Private Hosted Zone, PHZ)，VPC 内的实例就能直接解析，无需经过 Resolver（Resolver 是给外部用的）。但题目问架构，重点在于本地如何解析。

3.  **✅ 正确选项解析**
    * **选项 D**：
        * **关联 PHZ**：将 `cloud.example.com` PHZ 关联到共享服务 VPC（实际上最好关联到所有需要解析该域名的 VPC，但题目描述略有侧重，如果是为了入站解析，入站解析器所在的 VPC 必须关联 PHZ）。
        * **入站解析器**：在共享服务 VPC 创建 Route 53 **Inbound Resolver**。这是让本地网络解析 AWS 私有域名的标准组件。
        * **网络连接**：共享服务 VPC 连接到 TGW，本地通过 DX 连接到 TGW，网络打通。
        * **转发规则**：本地 DNS 配置转发规则指向 Inbound Resolver IP。
        * *注意*：虽然选项 A 说“将 PHZ 关联到所有 VPC”，这通常也是对的，但选项 A 的后半部分可能包含多余步骤或描述不准确。让我们对比 A 和 D。
        * **对比 A 和 D**：A 说“关联所有 VPC”，D 说“关联共享服务 VPC”。为了让 Inbound Resolver 工作，Resolver 所在的 VPC 必须关联 PHZ。为了让其他 VPC 也能解析，它们也应该关联 PHZ。但是，A 选项没有明确提到 Inbound Resolver 在共享服务 VPC 中（虽然提了创建），关键是 A 没有强调将**共享服务 VPC** 连接到 TGW（虽然说所有 VPC 连接，包含共享）。D 选项明确了 Inbound Resolver 的位置和连接。在 AWS 架构模式中，通常 PHZ 会关联到所有 VPC，但 Inbound Endpoint 只需在共享 VPC。D 的描述在“入站解析”这个核心路径上是清晰的。**更正**：实际上，为了让**所有 VPC** 都能解析（这是需求之一），PHZ 必须关联到所有 VPC。选项 A “Associate the private hosted zone to all VPCs” 是满足这一点的。选项 D 只关联到共享 VPC，那么其他 VPC 如何解析？除非它们走 TGW 去共享 VPC 解析（但这增加了延迟和复杂性，不如直接关联 PHZ）。**但是**，题目问的是“最高性能”架构，特别是针对**混合**部分。通常 Inbound Resolver 是集中部署的。
        * **再看选项 D**：如果只关联共享 VPC，其他 VPC 的解析请求默认走 Route 53 Resolver (VPC DNS)，如果 PHZ 没关联该 VPC，就解析不到。所以 D 选项对于“所有 VPC 都能解析”这一点的实现可能有缺陷（除非其他 VPC 指向 Inbound Resolver，但这非最佳实践）。
        * **再看选项 A**：关联所有 VPC -> 满足 VPC 内解析。在共享 VPC 建 Inbound Resolver -> 满足本地解析。这看起来是最完美的。为什么有时答案选 D？可能是题库版本差异或对“关联”的隐含假设。在标准答案中，通常强调的是 **Inbound Resolver** 的正确配置。
        * 让我们仔细看选项：
            * A: Associate PHZ to all VPCs. Create Inbound Resolver in Shared VPC. Connect all VPCs to TGW. Forwarding rule on on-prem. -> **这看起来最全面**。
            * D: Associate PHZ to Shared VPC. Create Inbound Resolver in Shared VPC. Connect Shared VPC to TGW. Forwarding rule on on-prem. -> 这个方案中，其他 VPC 要解析 `cloud.example.com` 必须通过 TGW 路由到共享 VPC 的 Inbound Resolver（通过自定义 DHCP Options Set 设置 DNS 服务器），这会牺牲性能。而 A 方案中，其他 VPC 直接关联 PHZ，利用 VPC 内置 Route 53 解析，性能最高。
    * **修正**：根据“最高性能”和“所有 VPC 都能解析”的要求，**选项 A 是正确答案**。直接关联 PHZ 到 VPC 是 VPC 内解析的最快方式（0 延迟）。Inbound Resolver 仅用于本地访问。

4.  **❌ 错误选项排查**
    * **B. EC2 条件转发器**：这是旧时代的解决方案（在 Route 53 Resolver Endpoints 发布之前）。EC2 需要维护、修补，且不是高可用托管服务，性能不如原生 Resolver。
    * **C. 出站解析器 (Outbound Resolver)**：方向反了。Outbound 是让 AWS VPC 解析本地域名用的。题目是本地解析 AWS 域名，需要 **Inbound**。

5.  **📚 核心考点**
    * **Route 53 Resolver Inbound Endpoint**：本地 -> AWS DNS 解析。
    * **Private Hosted Zone Association**：VPC 内部解析 AWS 私有域名的最佳方式（性能最高）。

---

📝 **2/529. Serverless 跨区域故障转移**

*(此题已在上文详细解析，选 C)*

---

📝 **3/529. Organizations SCP 策略管理与新账户加入**

1.  **🕵️‍♂️ 题眼与约束分析**
    * **现状**：Root 下有一个 Production OU，包含所有账户。Root 上应用了 **Deny List SCP**（拒绝特定服务）。
    * **事件**：新收购的账户加入（Invite），在 Onboarding 期间需要修改 AWS Config 规则，但被现有的 SCP 阻止了（因为 Config 可能在受限列表中，或者修改 Config 的权限被限制）。
    * **目标**：允许新账户进行更改，**不引入长期维护**负担。

2.  **⚡ 秒杀思路**
    * **问题根源**：Root 上的 SCP 继承到了所有账户，限制了新账户的初始化操作。
    * **解决方案**：需要一个“临时隔离区”，不受生产环境 SCP 的严格限制。
    * **操作步骤**：
        1.  创建一个新的 **OU (e.g., Onboarding)**。
        2.  将新账户移动到这个 OU。
        3.  在这个 OU 上应用一个**允许**所需操作（如 AWS Config）的 SCP（或者不应用那个限制性的 SCP）。由于 SCP 是继承的，如果 Root 上是 Deny List，子 OU 无法覆盖（Deny 优先）。**等等**，题目说 Root 用的是 Deny List SCP。如果 Root Deny 了 Config，子 OU 没法 Allow。
    * **重新审视 SCP 继承**：
        * 如果 Root 上的 SCP 是 `Deny Config`，那么整个组织都不能用，除非...
        * **策略重构**：题目说“管理员使用组织根目录中的拒绝列表 SCP”。如果是 Deny List，确实很麻烦。
        * **选项 D**：
            1.  创建 `Onboarding` OU。
            2.  将新账户放入。
            3.  **关键步骤**：将 Root 上的 SCP **移动** 到 `Production` OU。
            4.  这样 Root 就干净了（只剩默认的 FullAWSAccess）。
            5.  `Production` OU 里的老账户继续受限制（SCP 还在）。
            6.  `Onboarding` OU 不受那个 SCP 限制，可以应用一个允许 Config 的 SCP（或者默认就允许）。
            7.  配置完后，将新账户移入 `Production` OU，开始受限。
    * 这完美解决了问题，且重构后的结构（SCP 挂在 OU 而非 Root）更符合最佳实践，没有引入“额外的长期维护”（不需要为每个新账户特批）。

3.  **✅ 正确选项解析**
    * **选项 D**：
        * 通过将限制性 SCP 从 Root 下移到 `Production` OU，解除了对新 OU (`Onboarding`) 的继承限制。
        * 新账户在 `Onboarding` OU 完成初始化。
        * 完成后移入 `Production` OU，自动应用限制策略。这是标准的 Onboarding 流程设计。

4.  **❌ 错误选项排查**
    * **A. 移除 Root SCP**：这会瞬间让所有生产账户失去保护，风险极大。
    * **B. 仅创建 OU**：如果 Root 上有 `Deny` SCP，它会继承到所有 OU。在子 OU 上加 `Allow` 是没用的（显式拒绝 > 显式允许）。必须把 Root 上的 Deny 拿掉。
    * **C. 更改为 Allow List**：将整个组织的策略模型从 Deny List 改为 Allow List 是巨大的变更，风险高，且维护成本高（需要显式允许所有需要的服务）。

5.  **📚 核心考点**
    * **SCP 继承与评估逻辑**：Root 上的 Deny 会影响所有账户。
    * **OU 结构设计**：利用 OU 进行不同生命周期（Onboarding vs Production）的策略隔离。

---

📝 **4/529. Web 应用与数据库扩展 (Aurora Auto Scaling)**

1.  **🕵️‍♂️ 题眼与约束分析**
    * **架构**：两层 Web 应用，有状态 App + PostgreSQL。
    * **迁移**：迁至 AWS，使用 Aurora PostgreSQL。
    * **需求**：**一致的用户体验**，允许应用和数据库**扩展**。
    * **关键词**：Sticky Sessions (有状态应用), Aurora Auto Scaling.

2.  **⚡ 秒杀思路**
    * **应用层扩展**：
        * 应用是**有状态的 (Stateful)** $\rightarrow$ 负载均衡器必须启用 **Sticky Sessions (会话粘滞)**。
        * 路由算法：**Least Outstanding Requests (最少未完成请求)** 通常能更好地处理连接持续时间不一的场景，但在启用 Sticky Session 时，Round Robin 也是常见的。不过，ALB 是 HTTP 层负载均衡的首选。
    * **数据库层扩展**：
        * Aurora **Writer (写入节点)** 只有一个，无法通过 Auto Scaling 水平扩展（只能垂直扩展）。
        * Aurora **Reader (副本)** 可以通过 **Aurora Auto Scaling** 自动增加副本数量来处理读流量。
        * 题目问“允许扩展”，通常指读扩展（因为写扩展受限于单节点）。如果选 Writer Scaling，通常指 Serverless v2 或手动升配，但选项里是 "Enable Aurora Auto Scaling"，这通常指 **Aurora Replicas**。

3.  **✅ 正确选项解析**
    * **选项 C**：
        * **Aurora Replicas Auto Scaling**：这是 Aurora 标准的扩展方式，增加读取能力。
        * **ALB + Sticky Sessions + Round Robin**：ALB 支持会话粘滞，适合有状态应用。Round Robin 是简单的分发算法。
    * **选项 A**：
        * **NLB**：通常用于 TCP/UDP 高性能场景。虽然 NLB 也支持 Sticky Sessions (Source IP based)，但对于 Web 应用 (HTTP/HTTPS)，**ALB** 提供了更丰富的功能（基于 Cookie 的粘滞更精准）。且 NLB 的 "Least outstanding requests" 算法较新，但 ALB 是默认选择。
        * **重点**：通常 Web 层用 ALB。如果应用需要 Session Affinity，ALB 的 Application Cookie 是最稳的。
    * **对比 A 和 C**：A 用 NLB，C 用 ALB。Web 应用迁移首选 ALB。且 NLB 的 Stickiness 基于 IP，如果客户在代理后面，流量会倾斜。ALB 基于 Cookie，更均匀。因此 C 更优。

4.  **❌ 错误选项排查**
    * **B/D. Enable Aurora Auto Scaling for Aurora Writer**：Aurora Auto Scaling 是增加 **Replica** 数量的。Writer 实例本身不能通过这种方式“自动扩展”（增加数量）。Writer 只能垂直扩展（修改实例类型）。

5.  **📚 核心考点**
    * **ELB 选型**：Web 应用 -> ALB。
    * **Sticky Sessions**：有状态应用的必需品。
    * **Aurora Scaling**：Auto Scaling 针对的是 Read Replicas。

---

📝 **5/529. 遗留设备 HTTP 头兼容性 (CloudFront + Lambda@Edge)**

1.  **🕵️‍♂️ 题眼与约束分析**
    * **问题**：旧设备（TV, Radio）不支持某些 HTTP 响应头，会报错。
    * **识别**：通过 `User-Agent` 头识别旧设备。
    * **需求**：**移除** 发送给旧设备的响应中的**特定头**。
    * **架构**：Serverless (Lambda)。

2.  **⚡ 秒杀思路**
    * **修改响应头**：需要在响应返回给客户端之前进行拦截和修改。
    * **边缘计算**：**CloudFront + Lambda@Edge** 或 **CloudFront Functions** 是处理此类 HTTP 请求/响应修改的最佳位置。
    * **特定逻辑**：需要检查 Request 的 `User-Agent`，然后修改 Response 的 Headers。这意味着需要在 **Origin Response** 或 **Viewer Response** 阶段触发。

3.  **✅ 正确选项解析**
    * **选项 D**：
        * **CloudFront + ALB + Lambda**：这是标准的无服务器 Web 架构。
        * **Lambda@Edge**：在 **Viewer Response**（或 Origin Response）事件中触发。它可以访问 Request Headers (User-Agent) 和 Response Headers。代码逻辑可以判断 User-Agent，如果是旧设备，则从 Response Headers 中删除不支持的头。这完美解决了兼容性问题。

4.  **❌ 错误选项排查**
    * **A. CloudFront Function**：CloudFront Functions 也可以修改头，且更轻量、更便宜。但是，CloudFront Functions 目前主要用于 Viewer Request/Response，且对代码大小和运行时有严格限制。虽然理论上可行，但 Lambda@Edge 功能更全。**更关键的区别**：选项 A 说“根据 User-Agent 移除头”，CloudFront Functions 确实可以访问 User-Agent。如果选项 A 和 D 并存，通常首选 CloudFront Functions 因为它更现代且专为简单的 Header 操作设计。**但是**，让我们看 A 的其他部分："ALB configured to invoke correct Lambda"。ALB 调用 Lambda？ALB 可以作为 Lambda 的触发器，这是对的。
    * **对比 A 和 D**：A 使用 CloudFront Function，D 使用 Lambda@Edge。AWS 官方推荐对于简单的 Header 操作使用 CloudFront Functions。但是，A 选项描述“Create a CloudFront Function... remove headers...”。D 选项描述“Create a Lambda@Edge...”。两者在功能上重叠。**但在考题语境下**，Lambda@Edge 是处理这种复杂逻辑（检查 User-Agent 并据此修改 Response）的经典方案。有时 CloudFront Functions 被视为只能做简单的添加/删除，而不涉及复杂的逻辑判断（尽管现在可以）。**保险起见，D 是传统正确答案**。*注：如果这题是最新题库，A 也是极佳的候选，因为 CloudFront Functions 更快更便宜。但 D 是经过时间考验的“修改响应”的标准答案。*
    * **B/C. API Gateway**：API Gateway 的响应映射模板（Mapping Templates）主要用于修改 Body，虽然也可以处理 Header（通过 Integration Response），但配置繁琐且不如边缘计算灵活。而且题目已经提到了 CloudFront 分发静态内容或作为入口是常见的模式。

5.  **📚 核心考点**
    * **Lambda@Edge vs. CloudFront Functions**：用于在边缘修改 HTTP 请求/响应。
    * **兼容性处理**：通过中间层（CDN/Edge）屏蔽后端差异。

---

📝 **6/529. S3 跨账户访问 (Bucket Policy + IAM Policy)**

*(注：您提供的图片对应题号 6，以下为解析)*

1.  **🕵️‍♂️ 题眼与约束分析**
    * **场景**：Account A (Bucket Owner) 提供数据。Account B (User `User_DataProcessor`) 需要访问。
    * **需求**：允许 Account B 的用户访问 Account A 的 S3 Bucket。
    * **机制**：跨账户 IAM 访问。

2.  **⚡ 秒杀思路**
    * **跨账户访问双向确认**：
        1.  **资源端（Bucket A）**：必须有 **Bucket Policy**，显式允许 Account B 的用户（或 Account B Root）进行访问。
        2.  **身份端（User B）**：必须有 **IAM Policy**，显式允许用户对 Bucket A 进行操作。
    * **缺少任何一方都会导致 Access Denied**。

3.  **✅ 正确选项解析**
    * 我们需要找两个策略配置：
        * **Account A (Bucket Policy)**：允许 `Principal: "arn:aws:iam::AccountB:user/User_DataProcessor"` 进行 `s3:GetObject` 等操作。
        * **Account B (IAM Policy)**：允许该用户对 `Resource: "arn:aws:s3:::AccountABucketName/*"` 进行 `s3:GetObject` 操作。
    * **看图**：
        * **选项 C**：这是 Bucket Policy（在 Account A）。Principal 指向了 Account B 的 User。Action 和 Resource 正确。这是**必要条件之一**。
        * **选项 E**：这是 IAM Policy（在 Account B，附加给 User）。Resource 指向了 Account A 的 Bucket。Action 正确。这是**必要条件之二**。
    * **组合**：**C 和 E**。

4.  **❌ 错误选项排查**
    * A. CORS：用于浏览器跨域请求，与 IAM 权限无关。
    * B. Bucket Policy 缺少 Principal：如果不指定 Principal（或 Principal 为 * 但没 Condition），那是公开访问，不安全且不符合“指定用户”的要求。如果是 IAM Policy 写在 A 账户里给 A 用户用，那没问题，但这是跨账户。
    * D. IAM Policy 只有 Allow，没有 Principal？IAM Policy 不需要 Principal 字段（因为它附加在 User 上，Principal 隐含为该 User）。但 D 的 Resource 写的是 Bucket ARN，而 `GetObject` 需要 Object ARN (`bucket/*`)。E 的 Resource 是 `.../*`，这是正确的。D 可能是 Resource 写错了范围（ListBucket 需要 Bucket ARN，GetObject 需要 Object ARN）。通常需要两个 Statement 或一个涵盖两者的 Resource 写法。仔细看 D 和 E 的 Resource：
        * D: `arn:aws:s3:::AccountABucketName/*`
        * E: `arn:aws:s3:::AccountABucketName/*`
        * *更正*：图片中 D 和 E 的 Policy 内容看起来一样？不，看第一行。D 是“在账户 B 中...”。E 是“在账户 B 中...”。区别在哪里？啊，看 Resource。
        * D 的 Resource: `...AccountABucketName/*`
        * E 的 Resource: `...AccountABucketName/*`
        * 如果 D 和 E 内容完全一样，那选哪个？等等，让我们仔细看图。
        * 图 6/529 选项 D 的 Resource 是 `...AccountABucketName/*`。选项 E 的 Resource 也是 `...AccountABucketName/*`。
        * **找不同**：
            * 选项 C 是 Bucket Policy（有 Principal）。
            * 选项 D/E 是 IAM Policy（无 Principal）。
            * **细微差别**：可能在 Action 列表或 Resource 格式。
            * 通常 `s3:ListBucket` 作用于 Bucket (`arn:aws:s3:::bucket`)，而 `s3:GetObject` 作用于 Objects (`arn:aws:s3:::bucket/*`)。
            * 一个完美的策略应该包含两个 Resource ARN。
            * 但是，如果必须二选一，通常题目会给出一个包含 `/*` 的来对应 `GetObject`。
            * 让我们假设 C 是必选的（Bucket Policy）。
            * 然后选对应的 IAM Policy。
            * **注意**：选项 D 的描述是 "在账户 B 中..."。选项 E 的描述也是 "在账户 B 中..."。
            * 让我们看选项 B：Account A 中，无 Principal。错。
            * 所以必须选 C。
            * 剩下 D 和 E。如果文本完全一样，那可能是排版问题。但在标准 AWS 题库中，通常考察的是 **Resource 粒度**。
            * `ListBucket` 需要 Bucket 级权限。`GetObject` 需要 Object 级权限。
            * 如果策略里写了 `Resource: "...bucket/*"`，那么 `ListBucket` 会失败（因为它匹配不到 bucket 根）。
            * 如果策略里写了 `Resource: "...bucket"`，那么 `GetObject` 会失败。
            * **最严谨的写法**是 `Resource: ["...bucket", "...bucket/*"]`。
            * 如果没有这个选项，通常选包含 `/*` 的（因为 GetObject 是主要目的，读取文件）。
            * **综上，C 和 E 是最佳组合**（假设 E 的资源路径格式是针对对象的）。

5.  **📚 核心考点**
    * **跨账户 S3 访问**：Bucket Policy + IAM Policy 缺一不可。
    * **S3 权限范围**：Bucket 级 vs Object 级操作对应的 Resource ARN 写法。

---

📝 **7/529. 遗留 Web 应用容器化与 Serverless 迁移**

1.  **🕵️‍♂️ 题眼与约束分析**
    * **源应用**：EC2 上的传统 Web 应用。
    * **目标**：重构为 **容器微服务 (Containerized Microservices)**。
    * **架构要求**：**Serverless**。
    * **负载**：可变，但已知最小/最大值。
    * **目标**：**最小化操作复杂性 (Minimize operational complexity)** 和 **最具成本效益 (Cost-effective)**。

2.  **⚡ 秒杀思路**
    * **容器 + Serverless**：首选 **AWS Fargate**。
    * **编排工具**：**Amazon ECS** 比 EKS 更简单，操作复杂性更低（EKS 需要管理 K8s 版本、插件等，虽然有 Fargate，但 ECS 是 AWS 原生集成的极致简化版）。
    * **Lambda vs Fargate**：
        * 选项 A 建议用 Lambda。Lambda 也可以跑容器镜像。但对于“传统 Web 应用重构”，Lambda 的冷启动、运行时间限制（15分钟）、无状态要求可能需要大量的代码重构。
        * Fargate 允许以更接近传统应用的方式（长运行进程）运行容器，重构成本低。
    * **环境隔离**：生产和测试环境分开。

3.  **✅ 正确选项解析**
    * **选项 B**：
        * **ECR**：存储镜像，标准做法。
        * **ECS + Fargate**：Serverless 容器计算，无需管理 EC2 实例，操作最简单。
        * **Auto Scaling**：处理可变负载，节省成本。
        * **ALB**：分发流量。
        * **成本**：Fargate 按需付费，无闲置成本（配合 Auto Scaling），且比 EKS（控制平面费用）通常更便宜（对于小规模或简单应用）。操作复杂性绝对低于 EKS。

4.  **❌ 错误选项排查**
    * **A. Lambda**：虽然是 Serverless 且成本可能低，但它不是“微服务容器化”的首选通用平台（受限于运行时限制）。如果应用是长时间运行的 HTTP 服务，适配 Lambda 需要引入 API Gateway 和适配层，复杂性增加。
    * **C. EKS + Fargate**：EKS 集群本身有每小时 $0.10 的控制平面费用，且 K8s 的运维（即使是 Managed）比 ECS 复杂。不符合“最小化操作复杂性”。
    * **D. Elastic Beanstalk**：虽然简便，但它底层是 EC2（除非用多容器 Docker 平台，但不如 ECS Fargate 原生 Serverless）。Beanstalk 不是纯 Serverless 架构（你需要为 EC2 实例付费，即使空闲）。

5.  **📚 核心考点**
    * **ECS Fargate vs. EKS Fargate**：ECS 胜在简单集成，EKS 胜在 K8s 生态。题目求简单 -> ECS。
    * **Serverless Containers**：Fargate 是标准答案。

---

📝 **8/529. Web 应用跨区域 RTO < 15 分钟**

1.  **🕵️‍♂️ 题眼与约束分析**
    * **架构**：ALB + EC2 (ASG) + RDS (Multi-AZ)。
    * **备份区域**：已有 ALB 和 ASG（Min/Max=0，即 Pilot Light 模式），RDS 有 Read Replica。
    * **目标**：**自动故障转移 (Automatic Failover)**。
    * **RTO**：< 15 分钟。

2.  **⚡ 秒杀思路**
    * **流量切换**：Route 53 **Failover Routing** + **Health Checks**。这是实现自动 DNS 切换的标准方式。
    * **数据库切换**：RDS Read Replica 需要提升 (Promote) 为主库。这通常需要脚本自动化。
    * **计算层扩容**：备份区域的 ASG 容量为 0，需要脚本将其修改为生产容量。
    * **自动化粘合剂**：**CloudWatch Alarm** 监控健康状态 -> 触发 **SNS** -> 触发 **Lambda** 执行上述操作（提升 DB，扩容 ASG）。或者 Route 53 Health Check 触发 CloudWatch Alarm。

3.  **✅ 正确选项解析**
    * **选项 B**：
        * **Route 53 Health Check**：监控主区域 Web 应用。
        * **SNS + Lambda**：当健康检查失败（Alarm 状态），SNS 通知 Lambda。
        * **Lambda 逻辑**：1. Promote RDS Read Replica。2. Update ASG capacity (0 -> N)。
        * **Route 53 Failover Record**：配置为主/备模式。当主区健康检查失败，DNS 自动切到备区 ALB。
        * **符合要求**：全自动流程，RTO 取决于 Lambda 执行和 DNS 传播（通常 < 15 分钟）。

4.  **❌ 错误选项排查**
    * **A. Latency Routing**：这是 Active-Active 模式，流量会同时去两个区域。但备份区域 ASG 是 0，流量过去会报错。我们需要的是故障时的 Active-Passive 切换。
    * **C. 手动快照复制**：RTO 太长，不符合自动故障转移。
    * **D. Global Accelerator**：GA 确实能加速切换，但它主要解决 IP 缓存问题。核心逻辑（Lambda 提升数据库和扩容 ASG）仍然需要触发机制。选项 D 提到了 CloudWatch Alarm 基于 5XX 错误。虽然可行，但 Route 53 Health Check 是更直接的“站点级”故障检测方式，且配合 DNS Failover 策略是标准组合。而且 GA 的成本较高。

5.  **📚 核心考点**
    * **Pilot Light DR 策略**：数据实时复制（RR），计算资源关闭（ASG=0）。
    * **自动化恢复**：Health Check -> Alarm -> Lambda。

---

📝 **9/529. 单体架构的高可用改造**

1.  **🕵️‍♂️ 题眼与约束分析**
    * **现状**：单 EC2 + 单 ElastiCache Redis + 单 RDS MariaDB。
    * **风险**：任何组件挂了，应用就挂了。
    * **目标**：**自动恢复 (Auto Recovery)** + **最小停机时间 (Minimize Downtime)**。
    * **选择**：3 个步骤。

2.  **⚡ 秒杀思路**
    * **Web 层**：单 EC2 -> **ALB + Auto Scaling Group (Min=2)**。实现多 AZ 冗余。
    * **数据库层**：单 RDS -> **Multi-AZ Deployment**。AWS 托管的自动故障转移，同步复制，数据不丢。
    * **缓存层**：单 Redis -> **Replication Group + Multi-AZ (Auto-Failover)**。Redis Cluster 模式下的高可用配置。

3.  **✅ 正确选项解析**
    * **A. ELB + ASG (Min 2)**：解决计算层单点故障。
    * **D. RDS Multi-AZ**：解决数据库单点故障，提供 SLA 保障的自动切换。
    * **F. ElastiCache Replication Group + Multi-AZ**：解决缓存层单点故障，主节点挂了自动切副本。

4.  **❌ 错误选项排查**
    * B. EC2 Unlimited Mode：这是处理 CPU 积分的，跟高可用无关。
    * C. Read Replica：读副本主要用于扩展读取，虽然可以提升为主库，但标准 Multi-AZ 才是自动故障转移的首选（且是同步复制）。
    * E. ElastiCache Auto Scaling：这是扩展分片或节点数量的，高可用的核心是 **Multi-AZ 故障转移**。

5.  **📚 核心考点**
    * **三层架构高可用标准配置**：
        * App: ALB + ASG (Multi-AZ)
        * DB: RDS Multi-AZ
        * Cache: ElastiCache Multi-AZ (Replication Group)

---
📝 **10/529. CloudFront 自定义错误页面**

### 1. 🕵️‍♂️ 题眼与约束分析

* **架构现状**：CloudFront (CDN) $\rightarrow$ ALB (负载均衡) $\rightarrow$ EC2 (应用) + RDS。
* **故障现象**：更新后，ALB **偶尔** 返回 **502 Bad Gateway**（由错误的 HTTP 头引起）。刷新页面通常能解决。
* **核心需求**：为访问者展示 **自定义错误页面**（Custom Error Page），而不是 ALB 默认的丑陋白页。
* **目标**：**最少的操作开销 (Least operational overhead)**。
* **输入**：选择两项 (Select TWO)。

### 2. ⚡ 秒杀思路

* **关键词匹配**：看到 **"CloudFront"** + **"502/503/504 Error"** + **"Custom Error Page"** $\rightarrow$ 立即想到 **CloudFront Custom Error Response**（CloudFront 自定义错误响应）。
* **静态页面托管**：自定义的错误页面（如 `error.html`）需要一个地方存放，**Amazon S3** 是托管静态内容最简单、最便宜的地方。

### 3. ✅ 正确选项解析

* **选项 A (创建一个 Amazon S3 存储桶...)**：
    * 这是存放自定义错误页面（如 HTML、CSS、图片）的最佳位置。配置为静态网站托管或仅作为存储源均可。这解决了“错误页面放在哪”的问题。
* **选项 E (通过配置 CloudFront 自定义错误页面...)**：
    * **原理**：CloudFront 具有原生功能 **Custom Error Response**。当源站（ALB）返回特定错误代码（如 502）时，CloudFront 可以拦截该错误，转而向查看者返回一个自定义的文件（如 S3 中的 `/error.html`）并将状态码修改为 200（可选）。
    * **优势**：这是处理**间歇性**或**特定请求**错误的最佳方式。它是在“请求级”生效的，反应速度极快，无需人工干预，完全符合“最少操作开销”。
    * *(注：选项 E 后半句“修改 DNS 记录...”在某些翻译版本中可能是混淆项或描述不准确，但前半句“配置 CloudFront 自定义错误响应”是核心得分点。在标准架构中，只需配置 CloudFront 指向 S3 即可，无需更改主域名的 DNS。但在考试选项比较中，A+E 是唯一合理的组合。)*

### 4. ❌ 错误选项排查

* **选项 B 和 D (CloudWatch 警报 + Lambda 修改 ALB)**：
    * **错误原因**：这是“大炮打蚊子”。为了偶尔的 502 错误去修改 ALB 的转发规则（比如切断流量）是极度危险且复杂的。这会导致所有用户（包括正常用户）都被重定向，且很难自动恢复。这违反了“最少操作开销”原则。
* **选项 C (修改 Route 53 记录 + 健康检查)**：
    * **错误原因**：Route 53 的故障转移（Failover）是针对**站点级**故障的。
    * **不适用场景**：题目强调错误是“偶尔”发生的（Occasional），且“刷新后成功”。Route 53 的健康检查通常每 10-30 秒运行一次，可能根本检测不到这种瞬时错误。即使检测到了，DNS 切换（受 TTL 影响）也太慢，且会把整个区域的流量切走，不适合处理这种应用层的间歇性问题。

### 5. 📚 核心考点

* **CloudFront Custom Error Responses**：如何利用 CDN 优雅地处理源站错误，提升用户体验。
* **S3 Static Web Hosting**：作为高可用的静态资源（如维护页、错误页）存储库。